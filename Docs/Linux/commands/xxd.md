# xxd - Hex Dump

## Information
### Summary
```
xxd is a Hex Dump CLI utility that creates a hex dump of a given file or standard input.
```

### Description
+ xxd can also convert a hex dump back to its original binary form. 

- Like uuencode(1) and uudecode(1) it allows the transmission of binary data in a ‘mail-safe’ ASCII representation, but has the advantage of decoding to standard output.
    + Moreover, it can be used to perform binary file patching.

## Setup
### Dependencies
### Pre-Requisites
### Installation
- Using package manager
    - Package Names
        + apt : xxd
        + pacman : xxd
        + dnf : vim-common
    - apt-based (Debian)
        ```bash
        apt install xxd
        ```
    - pacman-based (ArchLinux)
        ```bash
        pacman -S xxd
        ```
    - dnf-based (Fedora/RHEL)
        ```bash
        dnf install vim-common
        ```

## Documentations
### Synopsis/Syntax
- Piping the standard output of a command into the standard input of xxd
    ```bash
    [command] | xxd {options} --
    ```

- Create a hex dump of a given file
    ```bash
    xxd {options} [input-file-name] [output-file-name]
    ```

### Parameters
- Positionals
    - input-file-name : Specify the input file to generate the hex dump of
        - Notes
            + If no infile is given, standard input is read. 
            + If infile is specified as a `-’ character, then input is taken from standard input. 
    - output-file-name : Specify the output file to write the generated hex dump to
        - Notes
            + If no outfile is given (or a `-’ character is in its place), results are sent to standard output.

- Optionals
    - With Arguments
        + `-c | -cols [cols]`             : format <cols> octets per line. Default 16 (-i: 12, -ps: 30, -b: 6). Max 256.
        + `-g | -groupsize [bytes]`       : separate the output of every <bytes> bytes (two hex characters or eight bit-digits each) by a whitespace. Specify -g 0 to suppress grouping. <Bytes> defaults to 2 in normal mode and 1 in bits mode. Grouping does not apply to postscript or include style.
        + `-l | -len [len]`               : stop after writing <len> octets.
        + `-seek [offset]`                : When used after -r: revert with <offset> added to file positions found in hexdump.
        + `-s {+|-}[seek]`                : start at <seek> bytes abs. (or rel.) infile offset. + indicates that the seek is relative to the current stdin file position (meaningless when not reading from stdin). - indicates that the seek should be that many characters from the end of the input (or if combined with +: before the current stdin file position). Without -s option, xxd starts at the current file position.
    - Flags
        + -a | -autoskip                  : toggle autoskip: A single ’*’ replaces nul-lines. Default off.
        + -b | -bits                      : Switch to bits (binary digits) dump, rather than hexdump. This option writes octets as eight digits "1"s and "0"s instead of a normal hexadecimal dump. Each line is preceded by a line number in hexadecimal and followed by an ascii (or ebcdic) representation. The command line switches -r, -p, -i do not work with this mode.
        + -E | -EBCDIC                    : Change the character encoding in the righthand column from ASCII to EBCDIC. This does not change the hexadecimal representation. The option is meaningless in combinations with -r, -p or -i.
        + -h | -help                      : print a summary of available commands and exit. No hex dumping is performed.
        + -i | -include                   : output in C include file style. A complete static array definition is written (named after the input file), unless xxd reads from stdin.
        + -p | -ps | -postscript | -plain : output in postscript continuous hexdump style. Also known as plain hexdump style.
        + -r | -revert                    : reverse operation: convert (or patch) hexdump into binary. If not writing to stdout, xxd writes into its output file without truncating it. Use the combination -r -p to read plain hexadecimal dumps without line number information and without a particular column layout. Additional Whitespace and line-breaks are allowed anywhere.
        + -u                              : use upper case hex letters. Default is lower case.
        + -v | -version                   : show version string.

### Usage
- Using dd to control the number of bytes to dump (potentially dangerous, be extra careful)
    - Explanation
        + `dd count=$len bs=1 status=none` : Write <len> number of bytes out`
        + '|' : Pipe the standard output (the bytes generated by dd) to the standard input of the target command
        + `xxd -p` : Dump the bytes to a hex string to perform pattern matching, pattern replace, data extraction etc etc
    ```bash
    hex=$(dd count=${len} bs=1 status=none) | xxd -p)
    ```

- Convert hexadecimal to ASCII using xxd
    - Explanation
        + Pipe a hexadecimal string standard output into xxd as standard input
        + `xxd -r -p` : Revert the hexadecimal string back into ASCII and then output/print the plaintext
        + `&& echo ''` : The standard output will get mixed with the prompt in the terminal because the converted output doesnt have any newline carriage returns, hence, append echo '' to make it more readable
    ```bash
    echo "hex-string-here" | xxd -r -p && echo ''
    ```

- Creating a simple hex dump of a given file
    ```bash
    xxd [input-file-name]
    ```

- Start converting from a specific line
    + Print everything but the first N lines (hex 0x(N*10) bytes) of a given file
    - Information
        + Where N = the number of lines you want to dump, and 0xN bytes = 0x(N*10) bytes
    ```bash
    xxd -s 0x(N*10) [input-file-name]
    ```

- Start converting from a specific Nth last line
    + Print N lines (hex 0x(N*10) bytes) from the end of a given file
    - Information
        + Where N = the number of lines (from the end) that you want to dump, and 0xN bytes = 0x(N*10) bytes
    ```bash
    xxd -s -0x(N*10) [input-file-name]
    ```

- Limit the output to a particular length
    - Information
        + Where N = the last line number to print to, and 0xN bytes = 0x(N*10) bytes
    ```bash
    xxd -l 0x(N*10) [input-file-name]
    ```

- Set the column length
    + Specify how many columns should be displayed on the output
    ```bash
    xxd -c [column-number] [input-file-name]
    ```

- Produce a binary dump instead of hexadecimal
    ```bash
    xxd -b [input-file-name]
    ```

- Get hex output in capital letters (uppercase)
    ```bash
    xxd -u [input-file-name]
    ```

- Revert the hexadecimal input/file to normal text again
    ```bash
    xxd -r [converted-hexadecimal-file]
    ```

- Print N bytes (hex 0x(N*10) bytes) as a continuous hexdump with X octets (0o(X*10)) per line
    - Information
        - Where 
            + N = the number of lines that you want to dump, 
            + X = the number of octets per line in the continuous hexdump
        - and
            + N bytes = 0x(N*10) bytes
            + X octets = 0o(X*10) octets
    ```bash
    xxd -l [length] -ps -c [number-of-columns] [input-file-name]
    ```

- Hex dump the first 120 bytes of a given file with 12 octets per line
    - Information
        + Row contains a value of length 120 in column 12 of the given file
    ```bash
    xxd -l [length] -c [number-of-columns] [input-file-name]
    ```

- Display a specific row found in a specific column, of a specific length in a specific hex value from a given file
    - Information
        + Row (hexadecimal value) 0x36 contains a cell value of length 13, is in column 13 of the given file
    ```bash
    xxd -s [specific-hex-value] -l [length] -c [column-number] [input-file-name]
    ```

- Copy an input file and prepend N bytes of value 0x00 to an output file
    ```bash
    xxd [input-file-name] | xxd -r -s N > [output-file-name]
    ```

## Wiki

### Snippets
- Print everything but the first 3 lines (hex 0x30 bytes) of a given file
    ```bash
    xxd -s 0x30 [input-file-name]
    ```

- Print 3 lines (hex 0x30 bytes) from the end of a given file
    ```bash
    xxd -s -0x30 [input-file-name]
    ```

- Print 120 bytes as a continuous hexdump with 40 octets (0o40) per line
    ```bash
    xxd -l 120 -ps -c 20 [input-file-name]
    ```

- Hex dump the first 120 bytes of a given file with 12 octets per line
    ```bash
    xxd -l 120 -c 12 [input-file-name]
    ```

- Copy an input file and prepend 100 bytes of value 0x00 to an output file
    ```bash
    xxd [input-file-name] | xxd -r -s 100 > [output-file-name]
    ```

### Notes
- xxd -r has some builtin magic while evaluating line number information. 
    - If the output file is seekable, then the linenumbers at the start of each hexdump line may be out of order, lines may be missing, or overlapping. 
        + In these cases xxd will lseek(2) to the next position. 
    + If the output file is not seekable, only gaps are allowed, which will be filled by null-bytes.
+ xxd -r never generates parse errors. Garbage is silently skipped.
- When editing hexdumps, 
    - xxd -r skips everything on the input line after reading enough columns of hexadecimal data (see option -c). 
        + This also means, that changes to the printable ascii (or ebcdic) columns are always ignored. 
    - Reverting a plain (or postscript) style hexdump with xxd -r -p does not depend on the correct number of columns. 
        + Anything that looks like a pair of hex-digits is interpreted.

## Resources

## References
+ [howtoforge - linux - command - xxd](https://www.howtoforge.com/linux-xxd-command/)
+ [linuxhandbook - command - xxd](https://linuxhandbook.com/xxd-command/)
+ [linuxhandbook - convert Hex to ASCII characters](https://linuxhandbook.com/convert-hex-ascii/)

## Remarks

