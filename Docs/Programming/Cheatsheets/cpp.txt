Cheatsheets - C Programming

Useful Libraries & Functions :
	C : 
		cstdlib.h
			fgets
			printf
		cstdio.h
		string.h
	C++ : 
		iostream
			cin
			cout
			endl
			getline
			sizeof
		stdlib
		stdio
		string
			string			: string var;
			to_string		: string str = to_string([variable]);
			getline			: getline([stream], [storage_variable]); 
		iomanip
			setprecision
			unsetf
		cmath
			abs
			fabs
			fabsf
		fstream
		ifstream
		ofstream
		sstream
		random
		time

Operators :
	+ : Add
	- : Subtract
	* : Multiply
	/ : Divide
	% : Modulus (Remainder)
	>> : Command Line Input Stream
	<< : Command Line Output Stream
	= : Assignnment Operator (Assigns value of right hand side (RHS) to left hand variable (LHS))
	== : Equality Comparison Operator (Checks if LHS and RHS are the same)
	! : NOT Operator (aka Negation Operator)
	?: : Ternary/Conditional Operator (? and : comes in a pair) [Syntax: expression-1 ? expression-2 : expression-3]
	& : Reference (Memory Address) Operator. Extracts Memory Address of variable; TLDR: Get the memory address of the target variable. Value passed into the function will be the exact same memory address of the caller's variable value; Caller's passed variable is associated with the function's implemented parameter
	* : Dereferencing Operator. Extracts value found in the memory address of a variable; TLDR: Get the value in a provided memory address
	-> : Arrow (Pointer-to-Member) Operator. Same usage as 'this'; Syntax: [pointer]->variable, Equivalent to '(*pointer).variable'. Examples: this->variable.
	. : Dot Operator
	:: : Scope Resolution (Namespace) Operator. Organisation Tools for Encapsulation; Syntax: [namespace]::[class], where using X::Y refers to class Y in namespace X.

Keywords:
	static : Memory remains allocated as long as the program executes
		- Used if you want the variable to not reinitialized everytime the function is looped/called
		- Alternative: global
	typedef : Type Definition, Can use typedef to define and use any object variables to represent the object type 
		- Syntax: typedef [data_type] [variable]
		- Examples:
			Array : typedef [data_type] [array_name] [NUM_OF_ROWS] [NUM_OF_COLS]
			enum : typedef enum [enum_name] { //values... } [type_variable];
			struct : typedef struct [struct_name] { [data_type] [variable_name]; } [struct_var];
	enum : 
		- Syntax: enum [enum_name] { //values... } [type_variable];
	struct : 
		- Syntax: struct [struct_name] { [data_type] [variable_name]; } [struct_var];
	new :
		- Dynamic pointers; Used to create dynamic variables
		- Syntax:
			new data_type;			// Ask OS for new mmeory enough to store [data_type]
			new data_type(value);	// Store value first then ask OS for new memory enough to store [data_type] and store it in the memory address of the value

			// To access allocated memory
			int mem = *p;
	delete :
		- Dynamic pointers; Used to destroy dynamic variables
		- Syntax:
			delete [pointer_variable] : To deallocate a single dynamic variable
			delete [] [pointer_variable] : To deallocate a dynamically created variable
	signed:
		- Default
		- Registers Negative values as well as positive values
		- Syntax:
	unsigned: 
		- Does not store negative numbers, registers positive ranges only
		- Syntax:
			unsigned [data_type] [variable] = [value];
	virtual:
		- To enable polymorphic behaviour
		- Syntax: 
			# General Usage in Class
			    virtual [statement]
			# Multiple Inheritance
			    class ChildClass : virtual public ParentClass1, virtual public ParentClass2 {...}
	override:
		- To provide a check on the use of a base class
		- Syntax:
			[statement] override;
	final:
		- To stop a class from being inherited
		- Syntax:
			class [class_name] final {};
    template:
        # To make a generic type template: 
            template <typename T>
            T function_name(T param) {};

        # To mix generic types:
            # Must overload the correct operators

        # To make multiple generic types in a function template:
            template <typename T, typename U>
            T function_name(T param, U param) {};

        # Default Template Arguments:
            # Use the library function-object template 'less' to set a default
            template <typename T, typename F=less<T>>
            function_name(T param1, T param2, F f=F()) {};
    typeid:
        - Syntax: typeid(class_obj);
    typename:
        - To implement variadic templates
        - Allow to take in any number of arguments in a template
        Syntax:
            template<typename T, typename... Args>
            void func(const T &t, const Args&... argv);
    sizeof:
        - Used to check number of arguments
        Syntax: sizeof(objects)

Macros :
	#define : #define [macro] [replacement_value]
	#extern : extern [definition_from_other_file];

Topics :
	File Handling :
		Libraries :
			fstream
			ifstream
			ofstream

		Modes:
			- To use multiple modes
				ios::[mode]_1 | ios::[mode]_2
			Syntax: [file_stream_object].open("file_name", ios::[modes]);
				in	: Open file for input (reading)
				out	: Open file for output (writing)
				app 	: Append, always write to the end, no overwrite
				ate 	: "At the end", On opening - go to the end.
				truc 	: Open file and wipes out existing content
				binary  : Open file to read/write in binary, doesnt have the text conversion layer

	Data Structure: 
		Vector:
            - Vector is a form of template
                - Vector takes in a generic type 'T' whereby
                    when you initialize a vector object of type 'T(n)', 
                    vector will take that type and replace generic type 'T' with 'T(n)'
                i.e. vector<T>
			Syntax:
				- To import: #include <vector>
				- To declare: vector<[data_type]> vector_obj;
				- To initialize: vector<[data_type]> vector_obj = [];
				- To get size of container: vector_obj.size();
				- To append: vector_obj.push_back(element)
				- To remove last element: vector_obj.pop_back()
				- To access elements: [data_type] element = vector_obj[index];

			Examples:
				#include <vector>	// Import vector
				vector<[data_type]> func_name(args)
				{
					vector<[data_type]> variable;		// Declare vector container
					variable.push_back(element);		// Append to vector container
					int vector_size = variable.size();	// Get size of vector
					[data_type] element = variable[index];	// Get element of vector
				}

	Makefile : 


	Encapsulation:
		File-Level:
			Access Modifiers:
				Syntax:
					// Definition Section (in .h file)
					class class_name {
						private:
							private_attributes;
							prototype_functions();
						public:
							prototype_functions();
					};

					// Implementation Section (in .cpp file)
					data_type class_name::function_name(params)
					{
						//statement
					}

				Examples:
					class student {
  						private:
		 					string name;
		 					int age;
		 					string password;
		 					bool verifyPassword();
						public:
		 					void display();
		 					bool login( string pswd );
					};

					void Student::display()
					{
						cout << name << " : " << age << endl;
					}

				To be a true file-level encapsulation:
					- Put header guard
						#ifndef HEADER_NAME
						#define HEADER_NAME
						/*
						 * "Definition Section" (Student.h)
				 		 */
				
						#endif 

			
			To generate .o file :
				g++ -c [source-file].cpp	// Pass source.o, source.h to friend

			To compile using .o file :
				g++ main1.cpp source.o -o main1.exe

	Inheritance:
		- Nested Classes

		Multiple Inheritance:
			- To avoid duplicate inheritance : Use the keyword 'virtual'
                        Syntax:
                            class ChildClass : virtual public ParentClass {
                                // Statements
                            }
                        Notes:
                            - Only use virtual in a inheritance (class ChildClass : virtual public ParentClass) when you plan or design to have multiple inheritance
                        Examples:
                            [1]
                                class Student : virtual public Person {…};
                                class Employee : virtual public Person {…};

                                class StudentEmployee : 
                                    virtual public Student, 
                                    virtual public Employee
                                {
                                    // Statements
                                };

	Polymorphism:
		Type casting: Use static_cast
			Syntax: static_cast<[type]*>(object);

Snippets:
	String Manipulation and Vector:
		/*
		 * Split String and Vector Test
		 */
		vector<string> splitString(string str, string delim)
		{
			vector<string> result;
			size_t pos = 0;
			string token;

			while( (pos = str.find(delim)) != string::npos )
			{
				// while string is not found
				token = str.substr(0, pos);
				result.push_back(token);
				str.erase(0, pos+delim.length());
			}

			if (!str.empty())
			{
				result.push_back(str);
			}
			return result;
		}

		int main()
		{
			string s = "John Doe 123";
			vector<string> dataItems = splitString(s, " ");
			for(size_t i =0; i < dataItems.size(); i++)
			{
				cout << dataItems[i] << endl;
			}
		}

Tips n Tricks : 
	Data Type :
		Conversion : 
			Convert negative integer to positive integer : abs([negative-integer])
			Convert negative double to positive double : fabs([negative-double])
			Convert negative float to positive float : fabsf([negative-float])

Templates:
	main : 
		C : 
			#include <stdlib.h>
			#include <stdio.h>
			#include <string.h>

			int main(int argc, const char *argv[])
			{
				/*
				* :: Params
				*		argc : Number of arguments
				*			Type: Integer 
				*		argv : Variable-Length arguments 
				*			Type: List
				*/
				printf("%s", "Hello World");
				return 1;
			}

		CPP : 
			#include <iostream>
			#include <cstdlib>
			#include <cstdio>
			#include <string>
			using std::cout;
			using std::cin;
			using std::endl;
			using std::getline;
			using std::string;
			using std::to_string;

			int main(int argc, const char *argv[])
			{
				/*
				* :: Params
				*		argc : Number of arguments
				*			Type: Integer 
				*		argv : Variable-Length arguments 
				*			Type: List
				*/
				cout << "Hello World" << endl;
				return 1;
			}

Resources : 
	Websites : 
		cplusplus.com
		geeksforgeeks.com
		tutorialspoint.com
